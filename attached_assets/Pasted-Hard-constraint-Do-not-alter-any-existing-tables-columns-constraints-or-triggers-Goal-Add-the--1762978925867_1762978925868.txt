Hard constraint: Do not alter any existing tables, columns, constraints, or triggers.
Goal: Add the Agency Account Creation flow using two new tables + FKs to public.agency and public."user".

1) PostgreSQL DDL (idempotent)
BEGIN;

-- ─────────────────────────────────────────────────────────────────────────────
-- 1) Main request table (mutable + optimistic lock)
-- ─────────────────────────────────────────────────────────────────────────────
CREATE TABLE IF NOT EXISTS public.agency_account_request (
  request_id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  -- Request payload (agency may or may not exist at submit time)
  agency_name         VARCHAR(120)       NOT NULL,
  contact_name        VARCHAR(80)        NOT NULL,
  contact_phone       VARCHAR(20)        NOT NULL,
  contact_email       CITEXT             NOT NULL,  -- case-insensitive compare
  reason_text         VARCHAR(255)       NOT NULL,

  -- Links (set after approval/provision)
  agency_id           INTEGER,
  user_id             INTEGER,

  -- Workflow: S=submitted, R=review, A=approved, D=denied
  status_code         CHAR(1)            NOT NULL,
  status_reason       VARCHAR(255),

  -- Audit & locking
  created_by_id       INTEGER            NOT NULL,  -- FK to public."user"(id)
  created_at          TIMESTAMP(0)       NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_by_id       INTEGER            NOT NULL,
  updated_at          TIMESTAMP(0)       NOT NULL DEFAULT CURRENT_TIMESTAMP,
  version_nbr         INTEGER            NOT NULL DEFAULT 1,

  CONSTRAINT c_aar_status
    CHECK (status_code IN ('S','R','A','D')),

  CONSTRAINT fk_aar_agency
    FOREIGN KEY (agency_id) REFERENCES public.agency(agency_id),

  CONSTRAINT fk_aar_user
    FOREIGN KEY (user_id) REFERENCES public."user"(id),

  CONSTRAINT fk_aar_created_by
    FOREIGN KEY (created_by_id) REFERENCES public."user"(id),

  CONSTRAINT fk_aar_updated_by
    FOREIGN KEY (updated_by_id) REFERENCES public."user"(id)
);

-- Exactly one *active* request per email while pending or under review
-- (functional partial unique index; allowed on new table)
CREATE UNIQUE INDEX IF NOT EXISTS uk_aar_active_email
  ON public.agency_account_request (lower(contact_email))
  WHERE status_code IN ('S','R');

-- Common filters
CREATE INDEX IF NOT EXISTS dk_aar_status_created
  ON public.agency_account_request (status_code, created_at);

-- Reuse existing trigger function set_updated_at() and keep column names aligned
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger
    WHERE tgname='trg_aar_set_updated_at'
      AND tgrelid='public.agency_account_request'::regclass
  ) THEN
    CREATE TRIGGER trg_aar_set_updated_at
      BEFORE UPDATE ON public.agency_account_request
      FOR EACH ROW
      EXECUTE PROCEDURE public.set_updated_at();
  END IF;
END$$;

-- ─────────────────────────────────────────────────────────────────────────────
-- 2) Immutable audit table (append-only)
-- ─────────────────────────────────────────────────────────────────────────────
CREATE TABLE IF NOT EXISTS public.agency_account_request_audit (
  audit_id            INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  request_id          INTEGER            NOT NULL,
  event_type          VARCHAR(24)        NOT NULL,  -- submitted | moved_to_review | approved | denied | provisioned
  event_notes         VARCHAR(255),
  actor_user_id       INTEGER            NOT NULL,  -- FK to public."user"(id)
  event_dtime         TIMESTAMP(0)       NOT NULL DEFAULT CURRENT_TIMESTAMP,
  version_nbr         INTEGER            NOT NULL DEFAULT 1,

  CONSTRAINT fk_aar_audit_req
    FOREIGN KEY (request_id) REFERENCES public.agency_account_request(request_id),

  CONSTRAINT fk_aar_actor
    FOREIGN KEY (actor_user_id) REFERENCES public."user"(id)
);

CREATE INDEX IF NOT EXISTS dk_aar_audit_req_time
  ON public.agency_account_request_audit (request_id, event_dtime);

COMMIT;

Optimistic-lock update pattern (use everywhere you mutate agency_account_request)
-- Example: S -> R (PEOD starts review)
UPDATE public.agency_account_request
SET status_code='R',
    updated_by_id=:actor_id,
    version_nbr=version_nbr+1
WHERE request_id=:id
  AND status_code='S'
  AND version_nbr=:v;      -- if 0 rows affected => concurrency conflict

2) Minimal service endpoints to wire

Submit (public/low-auth)
POST /account-requests

Validate payload.

Insert into agency_account_request with status_code='S', version_nbr=1.

Insert audit row submitted.

Notify ODPEM–PEOD.

PEOD review

GET /account-requests?status=S (list for triage)

POST /account-requests/{id}/start-review → S→R (optimistic lock) + audit moved_to_review

POST /account-requests/{id}/approve → R|S→A (+notes) + audit approved + notify Admin

POST /account-requests/{id}/deny → R|S→D (reason required) + audit denied + notify requester

Admin provision
POST /account-requests/{id}/provision

Find or create agency (must satisfy your existing SHELTER/DISTRIBUTOR/warehouse checks).

Create/activate user, set agency_id, is_active=true, status_code='A', version_nbr if not set.

Update the request with agency_id, user_id (optimistic lock).

Audit provisioned, send activation to requester.

⚠️ Email uniqueness & case: your existing public."user" uses VARCHAR(200) with UNIQUE. To avoid case-variant duplicates without changing that table, normalize to lowercase in the app layer on every insert/update and compare with lower(email) during login.

3) Sample SQL snippets (safe and aligned)

Insert request

INSERT INTO public.agency_account_request (
  agency_name, contact_name, contact_phone, contact_email, reason_text,
  status_code, status_reason, created_by_id, updated_by_id
) VALUES (
  :agency_name, :contact_name, :contact_phone, :contact_email, :reason_text,
  'S', NULL, :actor_id, :actor_id
)
RETURNING request_id, version_nbr;


Audit helper

INSERT INTO public.agency_account_request_audit (
  request_id, event_type, event_notes, actor_user_id
) VALUES (:id, :etype, :notes, :actor_id);


Approve (R|S → A)

UPDATE public.agency_account_request
SET status_code='A',
    status_reason=:notes,
    updated_by_id=:actor_id,
    version_nbr=version_nbr+1
WHERE request_id=:id
  AND status_code IN ('S','R')
  AND version_nbr=:v;


Link provisioned agency/user

UPDATE public.agency_account_request
SET agency_id=:agency_id,
    user_id=:user_id,
    updated_by_id=:admin_id,
    version_nbr=version_nbr+1
WHERE request_id=:id
  AND status_code='A'
  AND version_nbr=:v;

4) Guardrails to keep

No migrations touching existing tables. All additions are isolated.

All writes use optimistic locking. On conflict, return a friendly “stale data—refresh” message.

Reuse your set_updated_at() via triggers on the new table(s) so updated_at stays correct.

Respect agency constraints (SHELTER vs DISTRIBUTOR warehouse rule) when provisioning.